fmod PRINCIPAL is
  sort Prin .
  op eve : -> Prin [ctor] .
endfm

fmod POLYNOMIAL-B2 is
  pr INT .
  sort Poly .
  subsort Int < Poly .

  op _p+_ : Poly Poly -> Poly [assoc comm prec 33] .
  op _p*_ : Poly Poly -> Poly [assoc comm prec 31] .
  op invert : Poly -> Poly .

  vars P1 P2 P3 : Poly .
  vars M N : Nat .
  vars K K2 : NzNat .
  vars A B : Int .
  eq P1 p+ 0 = P1 .
  eq P1 p+ P1 = 0 .
  eq P1 p* 0 = 0 .
  eq P1 p* 1 = P1 .
  eq P1 p* (P2 p+ P3) = (P1 p* P2) p+ (P1 p* P3) .
  eq P1 p* invert(P1) = 1 .
endfm

fmod MSG-STATE is
  sort MsgState .
  ops sent replied intercepted : -> MsgState .
endfm

fmod MESSAGE is
  pr PRINCIPAL .
  pr POLYNOMIAL-B2 .
  pr MSG-STATE .
  sort Msg .

  op m1 : Prin Prin Prin Poly MsgState -> Msg [ctor] .
  op m2 : Prin Prin Prin Poly Poly MsgState -> Msg [ctor] .
endfm

fmod KEY is 
  pr POLYNOMIAL-B2 .
  pr PRINCIPAL .
  sort Key .

  op nil : -> Key [ctor] .
  op key : Poly Prin -> Key [ctor] .

endfm

fmod UTILS is
  pr POLYNOMIAL-B2 .

  sort PolyPair .

  op pair : Poly Poly -> PolyPair [ctor] .
  op 1st : PolyPair -> Poly .
  op 2nd : PolyPair -> Poly .
  op H : Poly -> PolyPair .
  op L : Poly Poly -> Poly .
  op K : Poly Poly Poly -> Poly .

--- input: h0,h1,c0
--- output: (e0,e1)
  op decode : Poly Poly Poly -> PolyPair .

  vars H0 H1 E0 E1 : Poly .
  eq decode(H0, H1, E0 p+ E1 p* (invert(H0) p* H1)) = pair(E0, E1) .

  eq 1st(pair(E0,E1)) = E0 .
  eq 2nd(pair(E0,E1)) = E1 .
endfm

fmod COLLECTION{X :: TRIV} is
  pr NAT .
  sort Collection{X} .
  subsort X$Elt < Collection{X} .
  op empty : -> Collection{X} [ctor] .
  op __ : Collection{X} Collection{X} -> Collection{X} [assoc comm id: empty ctor] .
  op _\in_ : X$Elt Collection{X} -> Bool .
  --- op size : List{X} -> Nat .

  var E : X$Elt .
  var C : Collection{X} .
  eq E \in (E C) = true .
  eq E \in C = false [owise] .
  --- eq size(empty) = 0 .
  --- eq size(E:X$Elt L:List{X}) = 1 + size(L:List{X}) .
endfm

fmod SLIST{X :: TRIV} is
  pr NAT .
  sort List{X} .
  subsort X$Elt < List{X} .
  op null : -> List{X} [ctor] .
  op _,_ : List{X} List{X} -> List{X} [assoc id: null ctor] .
endfm

view Poly from TRIV to POLYNOMIAL-B2 is
  sort Elt to Poly .
endv
view Msg from TRIV to MESSAGE is
  sort Elt to Msg .
endv
view Prin from TRIV to PRINCIPAL is
  sort Elt to Prin .
endv
view Key from TRIV to KEY is
  sort Elt to Key .
endv

fmod SOUP{D :: TRIV} is
  sort Soup{D} .
  subsort D$Elt < Soup{D} .
  op empty : -> Soup{D} [ctor] .
  op __ : Soup{D} Soup{D} -> Soup{D} [ctor assoc comm id: empty] .
endfm

fmod OCOMP is
  pr UTILS .
  pr COLLECTION{Poly} * (sort Collection{Poly} to ColPoly ) .
  pr SLIST{Poly} * (sort List{Poly} to ListPoly ) .
  pr COLLECTION{Msg} * (sort Collection{Msg} to ColMsg ) .
  pr COLLECTION{Prin} * (sort Collection{Prin} to ColPrin ) .
  pr COLLECTION{Key} * (sort Collection{Key} to ColKey ) .

  sort OComp .
  --- observable components
  op (nw:_) : ColMsg -> OComp [ctor] .  --- network
  --- op (polys:_) : ListPoly -> OComp [ctor] .
  op (key[_]:_) : Prin Key -> OComp [ctor] .
  op (prins:_) : ColPrin -> OComp [ctor] .
  op (h0[_]:_) : Prin Poly -> OComp [ctor] .
  op (h1[_]:_) : Prin Poly -> OComp [ctor] .
  op (m[_]:_) : Prin Poly -> OComp [ctor] .
  op (glean-m1:_) : ColMsg -> OComp [ctor] .
  op (glean-m2:_) : ColMsg -> OComp [ctor] . --- not need to maintain glean-m2
  op (keys:_) : ColKey -> OComp [ctor] . --- key obtained by eve
  op (h0s:_) : ColPoly -> OComp [ctor] .
  op (h1s:_) : ColPoly -> OComp [ctor] .
  op (ms:_) : ColPoly -> OComp [ctor] .
  op (rhs:_) : ListPoly -> OComp [ctor] .
  op (rms:_) : ListPoly -> OComp [ctor] .
endfm
  
view OComp from TRIV to OCOMP is
  sort Elt to OComp .
endv

fmod CONFIG is
  pr SOUP{OComp} .
  sort Config .
  op {_} : Soup{OComp} -> Config [ctor] .
  op init : -> Config .
  ops n p q : -> NzNat .

  ops po1 po2 po3 po4 po5 po6 po7 po8 po9 po10 : -> Poly .
  ops po11 po12 po13 po14 po15 po16 : -> Poly .
  ops ga gb ge : -> Poly .
  ops alice bob : -> Prin .

  eq init = {(nw: empty) (prins: (alice bob))
    (rhs: (po1, po2, po3, po4)) (rms: (po5, po6)) 
    (key[alice]: nil) (key[bob]: nil) (keys: empty)
    (h0[alice]: 0) (h0[bob]: 0) (h0s: empty) (h1s: empty) 
    (h1[alice]: 0) (h1[bob]: 0) (glean-m1: empty) (ms: empty) 
    (m[alice]: 0) (m[bob]: 0) (glean-m2: empty)} .
endfm

mod BIKE is 
  pr CONFIG .
  vars A B C : Prin .
  vars PoSM1 PoSM2 PoSM3 PoSM4 : ColPoly .
  vars KS : ColKey .
  vars PoS PoS2 PoS3 : ListPoly .
  vars K1 K2 K3 : Poly .
  vars KE1 KE2 KE3 : Key .
  vars MS MS2 MS3 : ColMsg .
  vars N P Q : Nat .
  var OCs : Soup{OComp} . 
  vars PS : ColPrin .
  vars Po1 Po2 Po3 Po4 Po5 Po6 Po7 : Poly .
  vars H0 H1 MP PK C0 C1 HE0 HE1 ME : Poly .
  vars M1 M2 M3 M4 : Msg .
  vars MsgStat MsgStat2 : MsgState .

--- keygen
  rl [keygen] : {(rhs: (H0, H1, PoS)) (h0[A]: 0) (h1[A]: 0)
    (prins: (A B PS)) (nw: MS)  OCs}
  => {(rhs: PoS) (h0[A]: H0) (h1[A]: H1) (prins: (A B PS)) 
    (nw: (MS m1(A,A,B, invert(H0) p* H1, sent))) OCs} .

--- encap
  rl [encap] : {(rms: (MP, PoS)) (m[B]: 0) (key[B]: KE1)
    (nw: (m1(C,A,B,PK,sent) MS)) OCs}
  => {(rms: PoS) (m[B]: MP)
    (key[B]: key(K(MP, 1st(H(MP)) p+ 2nd(H(MP)) p* PK,
      MP p+ L(1st(H(MP)), 2nd(H(MP)))), A))
    (nw: (m1(C,A,B,PK,replied) MS 
      m2(B,B,A, 1st(H(MP)) p+ 2nd(H(MP)) p* PK, 
        MP p+ L(1st(H(MP)), 2nd(H(MP))) , sent))) OCs} .

--- decap
  crl [decap] : {(h0[A]: H0) (h1[A]: H1) (key[A]: KE1)
    (nw: (m1(A,A,B, invert(H0) p* H1, MsgStat)
      m2(C,B,A,C0,C1,sent) MS)) OCs} 
  => {(h0[A]: H0) (h1[A]: H1)
    (key[A]: key(K(C1 p+ L(1st(decode(H0,H1,C0)), 2nd(decode(H0,H1,C0))), 
      C0, C1), B))
    (nw: (m1(A,A,B, invert(H0) p* H1, MsgStat)
      m2(C,B,A,C0,C1,replied) MS)) OCs} 
  if MsgStat =/= sent .

  rl [stutter] : {(rhs: null) OCs} => {(rhs: null) OCs} .

***(
  * eve intercepts a message m1 sent from alice to bob and
  * sends a fake message to bob
)
  rl [build-hs] : {(rhs: (HE0, HE1, PoS)) (h0s: PoSM1) 
    (h1s: PoSM2) OCs}
  => {(rhs: PoS) (h0s: (HE0 PoSM1)) (h1s: (HE1 PoSM2)) OCs} .

  rl [attack1] : {(h0s: (HE0 PoSM1)) (h1s: (HE1 PoSM2))
    (nw: (m1(A,A,B, PK, sent) MS)) OCs}
  => {(h0s: (HE0 PoSM1)) (h1s: (HE1 PoSM2))
    (nw: (m1(A,A,B, PK, intercepted) 
      m1(eve,A,B, invert(HE0) p* HE1, sent) MS)) OCs} .

  rl [build-ms] : {(rms: (ME, PoS)) (ms: PoSM3) OCs}
  => {(rms: PoS) (ms: (ME PoSM3)) OCs} .

  rl [attack2] : {(h0s: (HE0 PoSM1)) (h1s: (HE1 PoSM2)) (ms: (ME PoSM3))
    (nw: (m1(A,A,B, PK, intercepted)
      m1(eve,A,B, invert(HE0) p* HE1, replied)
      m2(B,B,A,C0,C1,sent) MS)) 
    (keys: KS) OCs}
  => {(h0s: (HE0 PoSM1)) (h1s: (HE1 PoSM2)) (ms: (ME PoSM3))
    (nw: (m1(A,A,B, PK, intercepted)
      m1(eve,A,B, invert(HE0) p* HE1, replied)
      m2(B,B,A,C0,C1,intercepted) 
      m2(eve,B,A, 1st(H(ME)) p+ 2nd(H(ME)) p* PK, 
        ME p+ L(1st(H(ME)), 2nd(H(ME))), sent) MS)) 
    (keys: (KS
      key(K(ME, 1st(H(ME)) p+ 2nd(H(ME)) p* PK,
        ME p+ L(1st(H(ME)), 2nd(H(ME)))), A) 
      key(K(C1 p+ L(1st(decode(HE0,HE1,C0)), 2nd(decode(HE0,HE1,C0))), 
        C0, C1), B) )) OCs} .
endm

search [1] in BIKE : 
  init =>* {(key[alice]: key(K1,bob)) (key[bob]: key(K2,alice)) 
    (keys: (key(K1,alice) key(K2,bob))) OCs} .
eof

search [1] in BIKE : 
  init =>* {(key[alice]: key(K1,bob)) (key[bob]: key(K1,alice)) OCs} . 
eof