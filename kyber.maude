fmod PRINCIPAL is
  sort Prin .
  op eve : -> Prin [ctor] .
endfm

fmod POLYNOMIAL is
  pr INT .
  sort Poly .
  subsort Int < Poly .

  op _p+_ : Poly Poly -> Poly [assoc comm prec 33] .
  op _p*_ : Poly Poly -> Poly [assoc comm prec 31] .
  op _p-_ : Poly Poly -> Poly [prec 33] .
  op neg_ : Poly -> Poly .

  vars P0 P1 P2 P3 : Poly .
  eq P1 p+ 0 = P1 .
  eq P1 p* 0 = 0 .
  eq P1 p* 1 = P1 .
  eq P1 p* (P2 p+ P3) = (P1 p* P2) p+ (P1 p* P3) .
  eq P1 p- P2 = P1 p+ neg(P2) .
  eq P1 p+ neg(P1) = 0 . 
  eq neg(neg(P1)) = P1 .
  eq neg(P1 p+ P2) = neg(P1) p+ neg(P2) .
endfm

view Poly from TRIV to POLYNOMIAL is
  sort Elt to Poly .
endv

fmod VECTOR is
  pr POLYNOMIAL .
  sort Vector .
  subsort Poly < Vector .
  op tpV : Vector -> Vector .        ---- transpose to a row vector

--- inner product
--- actually, the 1st (or 2nd) should be transposed
--- we consider only dot of two vectors having the same size
  op _dot_ : Vector Vector -> Poly [prec 31] .
  op _v+_ : Vector Vector -> Vector [assoc comm prec 33] .

  vars V1 V2 V3 : Vector .
  vars P1 P2 P3 : Poly .
  eq (V1 v+ V2) dot V3 = (V1 dot V3) p+ (V2 dot V3) .
  eq V3 dot (V1 v+ V2) = (V3 dot V1) p+ (V3 dot V2) .
  eq tpV(tpV(V1)) = V1 .
  eq tpV(V1 v+ V2) = tpV(V1) v+ tpV(V2) .
endfm

--- only consider square matrix
fmod MATRIX is
  pr VECTOR .
  sort Matrix .
  subsort Vector < Matrix .
  op tp : Matrix -> Matrix .        ---- transpose matrix
  op _m*_ : Matrix Vector -> Vector [prec 31] .

  vars M M2 : Matrix .
  vars V V2 : Vector .
  vars I J : Nat .
  vars P1 P2 P3 : Poly .

  eq tp(tp(M)) = M .
  eq tp(M m* M2) = tp(M2) m* tp(M) .

  op isSmall? : Matrix -> Bool .
  eq isSmall?(tp(M)) = isSmall?(M) .
  eq isSmall?(tpV(V)) = isSmall?(V) .
  ceq isSmall?(V v+ V2) = true 
    if (isSmall?(V) and isSmall?(V2)) .
  ceq isSmall?(V dot V2) = true 
    if (isSmall?(V) and isSmall?(V2)) .
  ceq isSmall?(P1 p+ P2) = true 
    if (isSmall?(P1) and isSmall?(P2)) .
  ceq isSmall?(neg(P1)) = true 
    if isSmall?(P1) .
  ceq isSmall?(M m* M2) = true 
    if (isSmall?(M) and isSmall?(M2)) .

  eq tpV(M m* V) dot V2 = tpV(V) dot (tp(M) m* V2) .
endfm

fmod POLY-PAIR is
  pr POLYNOMIAL .
  sort PolyPair .
  subsort Poly < PolyPair .

  op pair : Poly Poly -> PolyPair [ctor] .
  op 1st : PolyPair -> Poly .
  op 2nd : PolyPair -> Poly .

  vars H0 H1 E0 E1 : Poly .
  eq 1st(pair(E0,E1)) = E0 .
  eq 2nd(pair(E0,E1)) = E1 .
endfm

fmod ENCRYPTION is
  pr POLY-PAIR + MATRIX .

--- hash functions
  op H : Poly -> Poly .
  op H' : Vector Poly -> Poly .
  op G : PolyPair -> PolyPair .

--- key derivation function
  op KDF : Poly Poly -> Poly .

--- compress_q and decompress_q functions
  op decompr : Poly NzNat -> Poly .
  op decompr : Vector NzNat -> Vector .
  op compr : Poly NzNat -> Poly .
  op compr : Vector NzNat -> Vector .

  vars M : Poly .
  vars E0 E1 : Poly .
  ceq compr(E0 p+ decompr(M,1), 1) = M if isSmall?(E0) .
endfm

fmod SAMPLING is
  pr MATRIX .

  op sample-A  : Poly -> Matrix .

--- alice side
  op sample-s  : Poly -> Vector .
  op sample-e  : Poly -> Vector .

--- bob side
  op sample-r  : Poly -> Vector .
  op sample-e1 : Poly -> Vector .
  op sample-e2 : Poly -> Poly .

  vars P : Poly .
  eq isSmall?(sample-s(P)) = true .
  eq isSmall?(sample-e(P)) = true .
  eq isSmall?(sample-r(P)) = true .
  eq isSmall?(sample-e1(P)) = true .
  eq isSmall?(sample-e2(P)) = true .
endfm

fmod MSG-STATE is
  sort MsgState .
  ops sent replied intercepted : -> MsgState .
endfm

fmod MESSAGE is
  pr PRINCIPAL + POLY-PAIR + MATRIX + MSG-STATE .
  sort Msg .

--- As+e, and Rho
  op m1 : Prin Prin Prin Vector Poly MsgState -> Msg [ctor] .

--- pair(u,v)
  op m2 : Prin Prin Prin Vector Poly MsgState -> Msg [ctor] .
endfm

fmod KEY is 
  pr POLYNOMIAL .
  pr PRINCIPAL .
  sort Key .
  --- op nil : -> Key [ctor] .
  op key : Poly Prin -> Key [ctor] .
endfm

fmod COLLECTION{X :: TRIV} is
  pr NAT .
  sort Collection{X} .
  subsort X$Elt < Collection{X} .
  op empty : -> Collection{X} [ctor] .
  op __ : Collection{X} Collection{X} -> Collection{X} [assoc comm id: empty ctor] .
  op _\in_ : X$Elt Collection{X} -> Bool .

  var E : X$Elt .
  var C : Collection{X} .
  eq E \in (E C) = true .
  eq E \in C = false [owise] .
endfm

fmod SLIST{X :: TRIV} is
  pr NAT .
  sort List{X} .
  subsort X$Elt < List{X} .
  op null : -> List{X} [ctor] .
  op _,_ : List{X} List{X} -> List{X} [assoc id: null ctor] .
endfm

view Msg from TRIV to MESSAGE is
  sort Elt to Msg .
endv
view Prin from TRIV to PRINCIPAL is
  sort Elt to Prin .
endv
view Key from TRIV to KEY is
  sort Elt to Key .
endv

fmod SOUP{D :: TRIV} is
  sort Soup{D} .
  subsort D$Elt < Soup{D} .
  op empty : -> Soup{D} [ctor] .
  op __ : Soup{D} Soup{D} -> Soup{D} [ctor assoc comm id: empty] .
endfm

fmod OCOMP is
  pr ENCRYPTION .
  pr MATRIX .
  pr COLLECTION{Poly} * (sort Collection{Poly} to ColPoly ) .
  pr SLIST{Poly} * (sort List{Poly} to ListPoly ) .
  pr COLLECTION{Msg} * (sort Collection{Msg} to ColMsg ) .
  pr COLLECTION{Prin} * (sort Collection{Prin} to ColPrin ) .
  pr COLLECTION{Key} * (sort Collection{Key} to ColKey ) .

  sort OComp .
  --- observable components
  op (nw:_) : ColMsg -> OComp [ctor] .  --- network
  op (keys[_]:_) : Prin ColKey -> OComp [ctor] .
  op (prins:_) : ColPrin -> OComp [ctor] .

--- alice side
  op (d[_]:_) : Prin Poly -> OComp [ctor] .
  
--- bob side
  op (m[_]:_) : Prin Poly -> OComp [ctor] .

--- random parts
  op (rd-d:_) : ListPoly -> OComp [ctor] .
  op (rd-m:_) : ListPoly -> OComp [ctor] .

--- eve 
  op (glean-m1:_) : ColMsg -> OComp [ctor] .
  op (glean-m2:_) : ColMsg -> OComp [ctor] . 
  op (ds:_) : ColPoly -> OComp [ctor] .
  op (ms:_) : ColPoly -> OComp [ctor] .
  op (glean-keys:_) : ColKey -> OComp [ctor] . --- key obtained by eve
endfm

view OComp from TRIV to OCOMP is
  sort Elt to OComp .
endv

fmod CONFIG is
  pr SOUP{OComp} .
  sort Config .
  op {_} : Soup{OComp} -> Config [ctor] .
  op init : -> Config .
  ops n p q : -> NzNat .
  ops du dv : -> NzNat .

  op epsilon1 : Poly -> Poly .
  op epsilon2 : Vector -> Vector .
  var VP : Poly .
  var U : Vector .
  eq isSmall?(epsilon1(VP)) = true .
  eq isSmall?(epsilon2(U)) = true .
  eq decompr(compr(VP,dv),dv) = VP p+ epsilon1(VP) .
  eq decompr(compr(U,du),du) = U v+ epsilon2(U) .

  ops d1 d2 m1 m2 : -> Poly .
  ops alice bob : -> Prin .

  eq init = {(nw: empty) (prins: (alice bob))
    (rd-d: (d1 , d2)) (rd-m: (m1 , m2)) 
    (keys[alice]: empty) (keys[bob]: empty) (glean-keys: empty)
    (d[alice]: 0) (d[bob]: 0) (m[alice]: 0) (m[bob]: 0)
    (glean-m1: empty) (glean-m2: empty)
    (ds: empty) (ms: empty)} .
endfm

mod KYBER is 
  pr CONFIG + SAMPLING .
  vars A B C : Prin .
  vars PoC1 PoC2 PoC3 PoC4 : ColPoly .
  vars KS : ColKey .
  vars PoL PoL2 PoL3 : ListPoly .
  vars K1 K2 K3 : Poly .
  vars KE1 KE2 KE3 : Key .
  vars MS MS2 MS3 : ColMsg .
  vars N P Q : Nat .
  var OCs : Soup{OComp} . 
  vars PS : ColPrin .
  vars D D2 M M2 P1 P2 Rho RhoA M' V CV V' VB CVB VB' Rseed : Poly .
  vars PK T U CU U' UB CUB UB' TA : Vector .
  vars MG1 MG2 MG3 MG4 : Msg .
  vars MsgStat MsgStat2 : MsgState .
  vars Kr Kr2 RhoSig : PolyPair .

--- CPAPKE.enc: pk(= t + ro), m, r
  op enc-u : Vector Poly Poly Poly -> Vector .
  op enc-v : Vector Poly Poly Poly -> Poly .
  eq enc-u(T, Rho, M, Rseed) = compr(
    tp(sample-A(Rho)) m* sample-r(Rseed) v+ sample-e1(Rseed),
    du) .
  eq enc-v(T, Rho, M, Rseed) = compr(
    tpV(T) dot sample-r(Rseed) p+ sample-e2(Rseed) p+ decompr(M, 1),
    dv) .

--- keygen
  crl [keygen] : {(rd-d: (D, PoL)) (d[A]: P1) 
    (prins: (A B PS)) (nw: MS) OCs}
  => {(rd-d: PoL) (d[A]: D) 
    (prins: (A B PS)) 
    (nw: (MS m1(A,A,B, 
      sample-A(1st(RhoSig)) m* sample-s(2nd(RhoSig)) v+ 
        sample-e(2nd(RhoSig)), 
      1st(RhoSig), sent))) OCs} 
  if RhoSig := G(D) .

--- encaps
  crl [encap] : {(rd-m: (M, PoL)) (m[B]: P1) (keys[B]: KS)
    (nw: (m1(C,A,B,T,Rho,sent) MS)) OCs}
  => {(rd-m: PoL) (m[B]: M) 
    (keys[B]: (KS key(KDF(1st(Kr), H'(CU,CV)), A)))
    (nw: (m1(C,A,B,T,Rho,replied) 
      m2(B,B,A, CU, CV, sent) 
      MS)) OCs} 
  if M' := H(M) /\
    Kr := G(pair(M', H'(T, Rho))) /\
    CU := enc-u(T, Rho, M', 2nd(Kr)) /\
    CV := enc-v(T, Rho, M', 2nd(Kr)) .

--- decaps
  crl [decaps] : {(d[A]: D) (keys[A]: KS)
    (nw: (m1(A,A,B,T,Rho,MsgStat) 
      m2(C,B,A, CU, CV, sent) MS)) OCs}
  => {(d[A]: D) 
    (keys[A]: (KS key(KDF(1st(Kr2), H'(CU,CV)), B)))
    (nw: (m1(A,A,B,T,Rho,MsgStat) 
      m2(C,B,A, CU, CV, replied) MS)) OCs} 
  if RhoSig := G(D) /\
    Rho == 1st(RhoSig) /\
    T == sample-A(Rho) m* sample-s(2nd(RhoSig)) v+ sample-e(2nd(RhoSig)) /\
    U' := decompr(CU, du) /\
    V' := decompr(CV, dv) /\
    M2 := compr(V' p- tpV(sample-s(2nd(RhoSig))) dot U', 1) /\
    Kr2 := G(pair(M2, H'(T, Rho))) /\
    enc-u(T,Rho,M2,2nd(Kr2)) == CU /\
    enc-v(T,Rho,M2,2nd(Kr2)) == CV .

  rl [stutter] : {(rd-d: null) OCs} => {(rd-d: null) OCs} .

***(
  * eve intercepts a message m1 sent from alice to bob and
  * sends a fake message to bob
)
  rl [build-ds] : {(rd-d: (D, PoL)) (ds: PoC1) OCs}
  => {(rd-d: PoL) (ds: (PoC1 D)) OCs} .

  crl [attack1] : {(ds: (D PoC1))
    (nw: (m1(A,A,B, TA, RhoA, sent) MS)) OCs}
  => {(ds: (D PoC1))
    (nw: (m1(A,A,B, TA, RhoA, intercepted) 
      m1(eve,A,B, 
        sample-A(1st(RhoSig)) m* sample-s(2nd(RhoSig)) v+ 
          sample-e(2nd(RhoSig)), 
        1st(RhoSig), sent) MS)) OCs}
  if RhoSig := G(D) .

  rl [build-ms] : {(rd-m: (M, PoL)) (ms: PoC3) OCs}
  => {(rd-m: PoL) (ms: (PoC3 M)) OCs} .

  crl [attack2] : {(ds: (D PoC1)) (ms: (M PoC3))
    (nw: (m1(A,A,B, TA, RhoA, intercepted)
      m1(eve,A,B, T, Rho, replied)
      m2(B,B,A, CUB, CVB, sent) MS)) 
    (glean-keys: KS) OCs}
  => {(ds: (D PoC1)) (ms: (M PoC3))
    (nw: (m1(A,A,B, TA, RhoA, intercepted)
      m1(eve,A,B, T, Rho, replied)
      m2(B,B,A, CUB, CVB, intercepted) 
      
      m2(eve,B,A, CU, CV, sent) MS)) 
    (glean-keys: (KS
      key(KDF(1st(Kr), H'(CU,CV)), A) 
      key(KDF(1st(Kr2), H'(CUB, CVB)), B) )) OCs} 
  if RhoSig := G(D) /\
    Rho == 1st(RhoSig) /\
    T == sample-A(Rho) m* sample-s(2nd(RhoSig)) v+ sample-e(2nd(RhoSig)) /\
    UB' := decompr(CUB, du) /\
    VB' := decompr(CVB, dv) /\
    M2 := compr(VB' p- tpV(sample-s(2nd(RhoSig))) dot UB', 1) /\
    Kr2 := G(pair(M2, H'(T, Rho))) /\
    enc-u(T,Rho,M2,2nd(Kr2)) == CUB /\
    enc-v(T,Rho,M2,2nd(Kr2)) == CVB /\

    M' := H(M) /\
    Kr := G(pair(M', H'(TA, RhoA))) /\
    CU := enc-u(TA, RhoA, M', 2nd(Kr)) /\
    CV := enc-v(TA, RhoA, M', 2nd(Kr)) .
endm

search [1] in KYBER : 
  init =>* {(keys[alice]: key(K1,bob)) (keys[bob]: key(K2,alice)) 
    (glean-keys: (key(K1,alice) key(K2,bob) KS)) OCs} .
eof

search [1] in KYBER : 
  init =>* {(keys[alice]: key(K1,bob)) (keys[bob]: key(K1,alice)) OCs} . 
eof