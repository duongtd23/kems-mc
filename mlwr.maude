fmod PRINCIPAL is
  sort Prin .
  op eve : -> Prin [ctor] .
endfm

fmod FRACTION is 
  pr INT .
  sort Frac .
  subsort Int < Frac .

  op frac : Int Int -> Frac [ctor] .

endfm

fmod POLYNOMIAL is
  pr FRACTION .
  sort Poly .
  subsort Frac < Poly .

  op _p+_ : Poly Poly -> Poly [ctor assoc comm prec 33 gather (E e)] . --- should not use id: 0
  op _p*_ : Poly Poly -> Poly [ctor assoc comm prec 31 gather (E e)] . --- should not use id: 1
  op _p-_ : Poly Poly -> Poly [ctor prec 33 gather (E e)] .
  op _md_ : Poly Int -> Poly [ctor prec 32] . --- polynomial mod p
  op round : Poly -> Poly .
  op equal : Poly Poly -> Bool .        --- approximately equal

  vars P0 P1 P2 P3 : Poly .
  vars M N : Nat .
  vars K K2 : NzNat .
  vars A B C D : Int .
  eq P1 p+ 0 = P1 .
  eq P1 p* 0 = 0 .
  eq P1 p* 1 = P1 .

--- poly
  eq (K p* P1) md K = 0 .
  eq (P1 md K) md K = P1 md K .
  eq (P1 p+ (P2 md K)) md K = (P1 p+ P2) md K .
  eq (P1 p* (P2 md K)) md K = (P1 p* P2) md K .
  eq (P1 p+ K p* P2) md K = P1 md K .

  --- addition
  --- eq (P1 md K) md K = P1 md K .
  eq ((P1 md K) p+ P2) md K = (P1 p+ P2) md K .
  eq 0 md K = 0 .
  eq 1 md K = 1 .

  eq round((frac(A,B) p* (P0 md B)) md A)
    = round((frac(A,B) p* P0) md A) .
endfm

fmod VECTOR is
  pr POLYNOMIAL .
  sort Vector .
  subsort Poly < Vector .

--- inner product
--- actually, the 1st (or 2nd) should be transposed
--- we consider only dot of two vectors having the same size
  op _dot_ : Vector Vector -> Poly [prec 31] .
  op _v+_ : Vector Vector -> Vector [assoc comm prec 33] .
  op _mdv_ : Vector Int -> Vector [prec 32] . --- vector mod p
  op roundV : Vector -> Vector .
  op _v*_ : Frac Vector -> Vector [prec 31] .

  vars V1 V2 V3 : Vector .
  vars P1 P2 P3 : Poly .
  vars A B : Int .
  eq (V1 v+ V2) dot V3 = (V1 dot V3) p+ (V2 dot V3) .
  eq V3 dot (V1 v+ V2) = (V3 dot V1) p+ (V3 dot V2) .

  var K : Nat .
  eq (V1 mdv K) mdv K = V1 mdv K .
  eq ((V1 mdv K) v+ V2) mdv K = (V1 v+ V2) mdv K .

  eq roundV((frac(A,B) v* (V1 mdv B)) mdv A)
    = roundV((frac(A,B) v* V1) mdv A) .

  op isSmall? : Vector -> Bool .
endfm

--- only consider square matrix
fmod MATRIX is
  pr VECTOR .
  sort Matrix .
  subsort Vector < Matrix .
  op _m*_ : Matrix Vector -> Vector [prec 31] .
endfm

fmod SAMPLING is
  pr MATRIX .
  op hiho  : Poly -> Poly .
endfm

fmod MSG-STATE is
  sort MsgState .
  ops sent replied intercepted : -> MsgState .
endfm

fmod MESSAGE is
  pr PRINCIPAL + MATRIX + MSG-STATE .
  sort Msg .

--- x_1
  op m1 : Prin Prin Prin Vector MsgState -> Msg [ctor] .

--- x_2 and w_2
  op m2 : Prin Prin Prin Vector Poly MsgState -> Msg [ctor] .
endfm

fmod KEY is 
  pr POLYNOMIAL .
  pr PRINCIPAL .
  sort Key .
  op nil : -> Key [ctor] .
  op key : Poly Prin -> Key [ctor] .
endfm

fmod COLLECTION{X :: TRIV} is
  pr NAT .
  sort Collection{X} .
  subsort X$Elt < Collection{X} .
  op empty : -> Collection{X} [ctor] .
  op _;_ : Collection{X} Collection{X} -> Collection{X} [assoc comm id: empty ctor] .
  op _\in_ : X$Elt Collection{X} -> Bool .
  --- op size : List{X} -> Nat .

  var E : X$Elt .
  var C : Collection{X} .
  eq E \in (E ; C) = true .
  eq E \in C = false [owise] .
  --- eq size(empty) = 0 .
  --- eq size(E:X$Elt L:List{X}) = 1 + size(L:List{X}) .
endfm

fmod SLIST{X :: TRIV} is
  pr NAT .
  sort List{X} .
  subsort X$Elt < List{X} .
  op null : -> List{X} [ctor] .
  op _,_ : List{X} List{X} -> List{X} [assoc id: null ctor] .
endfm

view Poly from TRIV to POLYNOMIAL is
  sort Elt to Poly .
endv

view Msg from TRIV to MESSAGE is
  sort Elt to Msg .
endv
view Prin from TRIV to PRINCIPAL is
  sort Elt to Prin .
endv
view Key from TRIV to KEY is
  sort Elt to Key .
endv

view Vector from TRIV to VECTOR is
  sort Elt to Vector .
endv

fmod SOUP{D :: TRIV} is
  sort Soup{D} .
  subsort D$Elt < Soup{D} .
  op empty : -> Soup{D} [ctor] .
  op __ : Soup{D} Soup{D} -> Soup{D} [ctor assoc comm id: empty] .
endfm

fmod OCOMP is
  pr MATRIX .
  --- pr COLLECTION{Poly} * (sort Collection{Poly} to ColPoly ) .
  pr COLLECTION{Vector} * (sort Collection{Vector} to ColVector ) .
  pr SLIST{Vector} * (sort List{Vector} to ListVector ) .
  pr COLLECTION{Msg} * (sort Collection{Msg} to ColMsg ) .
  pr COLLECTION{Prin} * (sort Collection{Prin} to ColPrin ) .
  pr COLLECTION{Key} * (sort Collection{Key} to ColKey ) .

  sort OComp .
  --- observable components
  op (nw:_) : ColMsg -> OComp [ctor] .  --- network
  op (key[_]:_) : Prin Key -> OComp [ctor] .
  op (prins:_) : ColPrin -> OComp [ctor] .

--- alice and bob
  op (s[_]:_) : Prin Vector -> OComp [ctor] .
  
--- random parts
  op (rd-s:_) : ListVector -> OComp [ctor] .

--- eve 
  op (glean-m1:_) : ColMsg -> OComp [ctor] .
  op (glean-m2:_) : ColMsg -> OComp [ctor] . 
  op (ss:_) : ColVector -> OComp [ctor] .
  op (keys:_) : ColKey -> OComp [ctor] . --- key obtained by eve
endfm

view OComp from TRIV to OCOMP is
  sort Elt to OComp .
endv

fmod CONFIG is
  pr SOUP{OComp} + SAMPLING .
  sort Config .
  op {_} : Soup{OComp} -> Config [ctor] .
  op init : -> Config .

--- constants, known by everybody
  ops p q : -> NzNat .
  ops ma : -> Matrix .

  ops s1 s2 s3 s4 : -> Vector .
  ops alice bob : -> Prin .

  eq isSmall?(s1) = true .
  eq isSmall?(s2) = true .
  eq isSmall?(s3) = true .
  eq isSmall?(s4) = true .

  eq init = {(nw: empty) (prins: (alice ; bob))
    (rd-s: (s1 , s2 , s3 , s4))
    (key[alice]: nil) (key[bob]: nil) (keys: empty)
    (s[alice]: 0) (s[bob]: 0) 
    (glean-m1: empty) (glean-m2: empty) (ss: empty)} .

--- some approximation
  vars P1 P2 P3 M : Poly .
  vars S S' : Vector .
  vars MA : Matrix .
  vars K1 K2 : Poly .
  vars P Q : Int .

--- because p^2/8q = 2
  eq round(frac(p,q) p* 
      (K1 p- frac(p,4) p* hiho(K2) p+ frac(p,8))) md 2
    = round(frac(p,q) p* K1) md 2 .

--- approximately equal
  eq equal(P1 md P, P2 md P) = equal(P1, P2) .
  eq equal(round(P1), round(P2)) = equal(P1, P2) .

  ceq equal(
    frac(p,q) p* 
      (roundV(frac(p,q) v* (MA m* S') mdv p) dot S md p),
    frac(p,q) p* 
      (roundV(frac(p,q) v* (MA m* S) mdv p) dot S' md p)) 
    = true 
  if isSmall?(S) and isSmall?(S') .

endfm


mod MLWR is 
  pr CONFIG .
  vars A B C : Prin .
  vars PoV1 PoV2 PoV3 PoV4 : ColVector .
  vars VL VL2 VL3 : ListVector .
  vars KS : ColKey .
  vars K1 K2 K3 K1' K2' : Poly .
  vars KE1 KE2 KE3 : Key .
  vars MS MS2 MS3 : ColMsg .
  vars N P Q : Nat .
  var OCs : Soup{OComp} . 
  vars PS : ColPrin .
  vars S1 S2 X1 X2 V1 V2 SE XA XB : Vector .
  vars MG1 MG2 MG3 MG4 : Msg .
  vars MsgStat MsgStat2 : MsgState .
  vars MA : Matrix .
  vars W2 WB : Poly .

  rl [stutter] : {(rd-s: null) OCs} => {(rd-s: null) OCs} .

--- alice send msg #1
  crl [keygen] : {(rd-s: (S1, VL)) (s[A]: V1) 
    (prins: (A ; B ; PS)) (nw: MS) OCs}
  => {(rd-s: VL) (s[A]: S1) (prins: (A ; B ; PS)) 
    (nw: (MS ; m1(A,A,B, X1, sent))) OCs} 
  if X1 := roundV((frac(p,q) v* (ma m* S1 mdv q)) mdv p) .

--- encap
  crl [encap] : {(rd-s: (S2, VL)) (s[B]: V2) (key[B]: KE1)
    (nw: (m1(C,A,B, X1, sent) ; MS)) OCs}
  => {(rd-s: VL) (s[B]: S2) 
    (key[B]: key(round(frac(p,q) p* K2) md 2, A))
    (nw: (m1(C,A,B, X1, replied) ; 
      m2(B,B,A, X2, W2, sent) ;
      MS)) OCs} 
  if X2 := roundV((frac(p,q) v* (ma m* S2 mdv q)) mdv p) /\
    K2 := (X1 dot S2) md p /\
    W2 := hiho(K2) .

--- decap
  crl [decap] : {(s[A]: S1) (key[A]: KE1)
    (nw: (m1(A,A,B, X1, MsgStat) ; 
      m2(C,B,A, X2, W2, sent) ; MS)) OCs}
  => {(s[A]: S1) 
    (key[A]: key(round(frac(p,q) p* 
      (K1 p- frac(p,4) p* W2 p+ frac(p,8))) md 2, B))
    (nw: (m1(A,A,B, X1, MsgStat) ;
      m2(C,B,A, X2, W2, replied) ; MS)) OCs} 
  if X1 == roundV((frac(p,q) v* (ma m* S1 mdv q)) mdv p) /\
    K1 := (X2 dot S1) md p .

***(
  * eve intercepts a message m1 sent from alice to bob and
  * sends a fake message to bob
)
  rl [build-s] : {(rd-s: (SE, VL)) (ss: PoV1) OCs}
  => {(rd-s: VL) (ss: (SE ; PoV1)) OCs} .

  crl [attack1] : {(ss: (SE ; PoV1))
    (nw: (m1(A,A,B, XA, sent) ; MS)) OCs}
  => {(ss: (SE ; PoV1))
    (nw: (m1(A,A,B, XA, intercepted) ;
      m1(eve,A,B, X1, sent) ; MS)) OCs}
  if X1 := roundV((frac(p,q) v* (ma m* SE mdv q)) mdv p) .

  crl [attack2] : {(ss: (SE ; PoV1))
    (nw: (m1(A,A,B, XA, intercepted) ;
      m1(eve,A,B, X1, replied) ;
      m2(B,B,A, XB, WB, sent) ; MS)) 
    (keys: KS) OCs}
  => {(ss: (SE ; PoV1))
    (nw: (m1(A,A,B, XA, intercepted) ;
      m1(eve,A,B, X1, replied) ;
      m2(B,B,A, XB, WB, intercepted) ;
      m2(eve,B,A, X2, W2, sent) ; MS)) 
    (keys: (KS ;
      key(round(frac(p,q) p* 
        (K1 p- frac(p,4) p* WB p+ frac(p,8))) md 2, B) ;
      key(round(frac(p,q) p* K2) md 2, A) )) OCs} 
  if X1 == roundV((frac(p,q) v* (ma m* SE mdv q)) mdv p) /\
    K1 := (XB dot SE) md p /\

    X2 := roundV((frac(p,q) v* (ma m* SE mdv q)) mdv p) /\
    K2 := (XA dot SE) md p /\
    W2 := hiho(K2) .
endm

search [1] in MLWR : 
  init =>* {(key[alice]: key(K1,bob)) (key[bob]: key(K2,alice)) 
    (keys: (key(K1',alice) ; key(K2',bob))) OCs} 
  such that equal(K1, K1') and equal(K2, K2') .
eof

search [1] in MLWR : 
  init =>* {(key[alice]: key(K1,bob)) (key[bob]: key(K2,alice)) OCs} 
  such that equal(K1, K2) .
eof