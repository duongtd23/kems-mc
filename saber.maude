fmod PRINCIPAL is
  sort Prin .
  op eve : -> Prin [ctor] .
endfm

fmod POLYNOMIAL is
  pr INT .
  sort Poly .
  subsort Int < Poly .

  op _p+_ : Poly Poly -> Poly [ctor assoc comm prec 33 gather (E e)] . --- should not use id: 0
  op _p*_ : Poly Poly -> Poly [ctor assoc comm prec 31 gather (E e)] . --- should not use id: 1
  op _md_ : Poly Int -> Poly [ctor prec 32] . --- polynomial mod p
  op _p-_ : Poly Poly -> Poly [prec 33 gather (E e)] .
  op neg_ : Poly -> Poly [ctor] .

  vars P0 P1 P2 P3 : Poly .
  vars M N : Nat .
  vars K K2 : NzNat .
  vars A B : Int .
  eq P1 p+ 0 = P1 .
  eq P1 p* 0 = 0 .
  eq P1 p* 1 = P1 .
  eq P1 p* (P2 p+ P3) = (P1 p* P2) p+ (P1 p* P3) .

--- poly
  eq (K p* P1) md K = 0 .
  eq (P1 md K) md K = P1 md K .
  eq (P1 p+ (P2 md K)) md K = (P1 p+ P2) md K .
  eq (P1 p* (P2 md K)) md K = (P1 p* P2) md K .
  eq (P1 p+ K p* P2) md K = P1 md K .

  --- addition
  --- eq (P1 md K) md K = P1 md K .
  eq ((P1 md K) p+ P2) md K = (P1 p+ P2) md K .
  eq 0 md K = 0 .
  eq 1 md K = 1 .

---subtraction
  eq P1 p- P2 = P1 p+ neg(P2) .
  eq P1 p+ neg(P1) = 0 . 
  eq neg(neg(P1)) = P1 .
  eq neg(P1 p+ P2) = neg(P1) p+ neg(P2) .
  eq neg(P1 md K) = neg(P1) md K .

--- bit shift
--- shift right
  op shiftR : Poly Int -> Poly .

  op _^_ : Int Int -> Int [prec 29 gather (E e) special (
    id-hook NumberOpSymbol (^)
    op-hook succSymbol (s_ : Nat ~> NzNat)
    op-hook minusSymbol (-_ : NzNat ~> Int))] .
endfm

view Poly from TRIV to POLYNOMIAL is
  sort Elt to Poly .
endv

fmod VECTOR is
  pr POLYNOMIAL .
  sort Vector .
  subsort Poly < Vector .
  op tpV : Vector -> Vector .        ---- transpose to a row vector

--- inner product
--- actually, the 1st (or 2nd) should be transposed
--- we consider only dot of two vectors having the same size
  op _dot_ : Vector Vector -> Poly [prec 31] .
  op _v+_ : Vector Vector -> Vector [assoc comm prec 33] .
  op _mdv_ : Vector Nat -> Vector [prec 32] . --- vector mod p

  vars V1 V2 V3 : Vector .
  vars P1 P2 P3 : Poly .
  eq (V1 v+ V2) dot V3 = (V1 dot V3) p+ (V2 dot V3) .
  eq V3 dot (V1 v+ V2) = (V3 dot V1) p+ (V3 dot V2) .
  eq tpV(tpV(V1)) = V1 .
  eq tpV(V1 v+ V2) = tpV(V1) v+ tpV(V2) .

  var K : Nat .
  eq (V1 mdv K) mdv K = V1 mdv K .
  eq ((V1 mdv K) v+ V2) mdv K = (V1 v+ V2) mdv K .

--- bit shift
--- shift right
  op shiftRV : Vector Int -> Vector .
endfm

--- only consider square matrix
fmod MATRIX is
  pr VECTOR .
  sort Matrix .
  subsort Vector < Matrix .
  op tp : Matrix -> Matrix .        ---- transpose matrix
  op _m*_ : Matrix Vector -> Vector [prec 31] .

  vars M M2 : Matrix .
  vars V V2 : Vector .
  vars I J : Nat .
  vars P1 P2 P3 : Poly .

  eq tp(tp(M)) = M .
  --- eq tp(M m* M2) = tp(M2) m* tp(M) .

  op isSmall? : Matrix -> Bool .
  eq isSmall?(tp(M)) = isSmall?(M) .
  eq isSmall?(tpV(V)) = isSmall?(V) .
  ceq isSmall?(V v+ V2) = true 
    if (isSmall?(V) and isSmall?(V2)) .
  ceq isSmall?(V dot V2) = true 
    if (isSmall?(V) and isSmall?(V2)) .
  ceq isSmall?(P1 p- P2) = true 
    if (isSmall?(P1) and isSmall?(P2)) .
  ceq isSmall?(P1 p+ P2) = true 
    if (isSmall?(P1) and isSmall?(P2)) .
  ceq isSmall?(M m* M2) = true 
    if (isSmall?(M) and isSmall?(M2)) .

  --- eq tpV(M m* V) dot V2 = tpV(V) dot (tp(M) m* V2) .
endfm

fmod POLY-PAIR is
  pr POLYNOMIAL .
  sort PolyPair .
  --- subsort Poly < PolyPair .

  op pair : Poly Poly -> PolyPair [ctor] .
  op 1st : PolyPair -> Poly .
  op 2nd : PolyPair -> Poly .

  vars H0 H1 E0 E1 : Poly .
  eq 1st(pair(E0,E1)) = E0 .
  eq 2nd(pair(E0,E1)) = E1 .
endfm

fmod POLY-VECTOR-PAIR is
  pr VECTOR .
  sort PVPair .
  --- subsort Poly < PolyPair .

  op pvPair : Poly Vector -> PVPair [ctor] .
  op 1st : PVPair -> Poly .
  op 2nd : PVPair -> Vector .

  vars E0 E1 : Poly .
  vars V0 V1 : Vector .
  eq 1st(pvPair(E0,V0)) = E0 .
  eq 2nd(pvPair(E0,V0)) = V0 .
  eq (pvPair(E0,V0) == pvPair(E1,V1)) 
    = (E0 == E1 and V0 == V1) . 
endfm

fmod ENCRYPTION is
  pr POLY-PAIR + POLY-VECTOR-PAIR + MATRIX .

--- hash functions
  op F : PVPair -> Poly .
  op G : Poly Poly -> PolyPair .
  op H : Poly PVPair -> Poly .
endfm

fmod SAMPLING is
  pr MATRIX .

  op gen-A : Poly -> Matrix .
  op gen-s : Poly -> Vector .

  vars P : Poly .
  eq isSmall?(gen-s(P)) = true .
endfm

fmod MSG-STATE is
  sort MsgState .
  ops sent replied intercepted : -> MsgState .
endfm

fmod MESSAGE is
  pr PRINCIPAL + POLY-PAIR + POLY-VECTOR-PAIR + MATRIX + MSG-STATE .
  sort Msg .

--- seed_A and b
  op m1 : Prin Prin Prin PVPair MsgState -> Msg [ctor] .

--- c_m and b'
  op m2 : Prin Prin Prin PVPair MsgState -> Msg [ctor] .
endfm

fmod KEY is 
  pr POLYNOMIAL .
  pr PRINCIPAL .
  sort Key .
  op nil : -> Key [ctor] .
  op key : Poly Prin -> Key [ctor] .
endfm

fmod COLLECTION{X :: TRIV} is
  pr NAT .
  sort Collection{X} .
  subsort X$Elt < Collection{X} .
  op empty : -> Collection{X} [ctor] .
  op _;_ : Collection{X} Collection{X} -> Collection{X} [assoc comm id: empty ctor] .
  op _\in_ : X$Elt Collection{X} -> Bool .

  var E : X$Elt .
  var C : Collection{X} .
  eq E \in (E ; C) = true .
  eq E \in C = false [owise] .
endfm

fmod SLIST{X :: TRIV} is
  pr NAT .
  sort List{X} .
  subsort X$Elt < List{X} .
  op null : -> List{X} [ctor] .
  op _,_ : List{X} List{X} -> List{X} [assoc id: null ctor] .
endfm

view Msg from TRIV to MESSAGE is
  sort Elt to Msg .
endv
view Prin from TRIV to PRINCIPAL is
  sort Elt to Prin .
endv
view Key from TRIV to KEY is
  sort Elt to Key .
endv

fmod SOUP{D :: TRIV} is
  sort Soup{D} .
  subsort D$Elt < Soup{D} .
  op empty : -> Soup{D} [ctor] .
  op __ : Soup{D} Soup{D} -> Soup{D} [ctor assoc comm id: empty] .
endfm

fmod OCOMP is
  pr ENCRYPTION .
  pr MATRIX .
  pr COLLECTION{Poly} * (sort Collection{Poly} to ColPoly ) .
  pr SLIST{Poly} * (sort List{Poly} to ListPoly ) .
  pr COLLECTION{Msg} * (sort Collection{Msg} to ColMsg ) .
  pr COLLECTION{Prin} * (sort Collection{Prin} to ColPrin ) .
  pr COLLECTION{Key} * (sort Collection{Key} to ColKey ) .

  sort OComp .
  --- observable components
  op (nw:_) : ColMsg -> OComp [ctor] .  --- network
  op (key[_]:_) : Prin Key -> OComp [ctor] .
  op (prins:_) : ColPrin -> OComp [ctor] .

--- alice side
  op (seed[_]:_) : Prin Poly -> OComp [ctor] .
  op (r[_]:_) : Prin Poly -> OComp [ctor] .
  
--- bob side
  op (m[_]:_) : Prin Poly -> OComp [ctor] .

--- random parts
  op (rd-seed:_) : ListPoly -> OComp [ctor] .
  op (rd-r:_) : ListPoly -> OComp [ctor] .
  op (rd-m:_) : ListPoly -> OComp [ctor] .

--- eve 
  op (glean-m1:_) : ColMsg -> OComp [ctor] .
  op (glean-m2:_) : ColMsg -> OComp [ctor] . 
  op (seeds:_) : ColPoly -> OComp [ctor] .
  op (rs:_) : ColPoly -> OComp [ctor] .
  op (ms:_) : ColPoly -> OComp [ctor] .
  op (keys:_) : ColKey -> OComp [ctor] . --- key obtained by eve
endfm

view OComp from TRIV to OCOMP is
  sort Elt to OComp .
endv

fmod CONFIG is
  pr SOUP{OComp} .
  sort Config .
  op {_} : Soup{OComp} -> Config [ctor] .
  op init : -> Config .

--- constants, known by everybody
  ops esp esq esT : -> NzNat .
  ops h1 h2 : -> Poly .
  ops h : -> Vector .
  ops p q t : -> NzNat .
  --- eq p = 2 ^ esp .
  --- eq q = 2 ^ esq .
  --- eq t = 2 ^ esT .

  ops seed1 seed2 r1 r2 m1 m2 : -> Poly .
  ops alice bob : -> Prin .

  eq init = {(nw: empty) (prins: (alice ; bob ; eve))
    (rd-seed: (seed1 , seed2)) (rd-r: (r1 , r2)) (rd-m: (m1 , m2)) 
    (key[alice]: nil) (key[bob]: nil) (keys: empty)
    (seed[alice]: 0) (seed[bob]: 0) (r[alice]: 0) (r[bob]: 0)
    (m[alice]: 0) (m[bob]: 0) (glean-m1: empty) (glean-m2: empty)
    (seeds: empty) (rs: empty) (ms: empty)} .

--- some approximation
  vars P1 P2 P3 M CM : Poly .
  vars S S' B B' : Vector .
  vars MA : Matrix .
  vars K Q K2 PT 2PT 2P1 : Int .

--- approximation
  ceq tpV(shiftRV( (MA m* S' v+ h) mdv q, esq - esp )) dot S
    p+ neg(tpV(shiftRV( (tp(MA) m* S v+ h) mdv q, esq - esp )) dot S') = 0
  if isSmall?(S) and isSmall?(S') . 

  ceq 2PT p* shiftR(CM, PT) = CM 
  if PT := esp - esT /\
     2PT := 2 ^ PT .

  ceq shiftR( (h2 p+ neg(h1) p+ 2P1 p* M) md p, esp - 1) = M
  if 2P1 := 2 ^ (esp - 1) .
endfm

mod SABER is 
  pr CONFIG + SAMPLING .
  vars A B C : Prin .
  vars PoC1 PoC2 PoC3 PoC4 : ColPoly .
  vars KS : ColKey .
  vars PoL PoL2 PoL3 : ListPoly .
  vars K1 K2 K3 : Poly .
  vars KE1 KE2 KE3 : Key .
  vars MS MS2 MS3 : ColMsg .
  vars N : Nat .
  var OCs : Soup{OComp} . 
  vars PS : ColPrin .
  vars M M2 SD M' R V V' Po1 Po2 CM SD-A CM-B : Poly .
  vars VB VB' PK T U UB TA S S' VB-A VB'-B : Vector .
  vars MG1 MG2 MG3 MG4 : Msg .
  vars MsgStat MsgStat2 : MsgState .
  vars Kr Kr' RoSig : PolyPair .
  vars MA : Matrix .
  vars CB CB' : PVPair .

--- PKE.enc: seed, b, m, r
  op enc : Poly Vector Poly Poly -> PVPair .
  ceq enc(SD, VB, M, R) = 
    pvPair(CM, VB')
  if MA := gen-A(SD) /\
    S' := gen-s(R) /\
    VB' := shiftRV((MA m* S' v+ h) mdv q, esq - esp) /\
    V' := tpV(VB) dot S' /\
    CM := shiftR( (V' p+ h1 p- (2 ^ (esp - 1)) p* M) md p, esp - esT) .

--- keygen
  crl [keygen] : {(rd-seed: (SD, PoL)) (rd-r: (R, PoL2)) 
    (seed[A]: Po1) (r[A]: Po2) 
    (prins: (A ; B ; PS)) (nw: MS) OCs}
  => {(rd-seed: PoL) (rd-r: PoL2) (seed[A]: SD) (r[A]: R) 
    (prins: (A ; B ; PS)) 
    (nw: (MS ; m1(A,A,B, pvPair(SD, VB), sent))) OCs} 
  if MA := gen-A(SD) /\
    S := gen-s(R) /\
    VB := shiftRV((tp(MA) m* S v+ h) mdv q, esq - esp) .

--- encap
  crl [encap] : {(rd-m: (M, PoL)) (m[B]: Po1) (key[B]: KE1)
    (nw: (m1(C,A,B, pvPair(SD,VB), sent) ; MS)) OCs}
  => {(rd-m: PoL) (m[B]: M) 
    (key[B]: key( H(1st(Kr), CB) , A))
    (nw: (m1(C,A,B, pvPair(SD, VB), replied) ; 
      m2(B,B,A, CB, sent) ;
      MS)) OCs} 
  if Kr := G(F(pvPair(SD,VB)), M) /\
    CB := enc(SD,VB,M,2nd(Kr)) .

--- decap
  crl [decap] : {(seed[A]: SD) (r[A]: R)  (key[A]: KE1)
    (nw: (m1(A,A,B, pvPair(SD,VB), MsgStat) ; 
      m2(C,B,A, pvPair(CM,VB'), sent) ; MS)) OCs}
  => {(seed[A]: SD) (r[A]: R) 
    (key[A]: key( H(1st(Kr'),CB') , B))
    (nw: (m1(A,A,B, pvPair(SD,VB), MsgStat) ;
      m2(C,B,A, pvPair(CM,VB'), replied) ; MS)) OCs} 
  if MA := gen-A(SD) /\
    S := gen-s(R) /\
    VB == shiftRV((tp(MA) m* S v+ h) mdv q, esq - esp) /\
    V := tpV(VB') dot S /\
    M' := shiftR((V p+ h2 p- 2 ^ (esp - esT) p* CM) md p, esp - 1) /\
    Kr' := G(F(pvPair(SD,VB)), M') /\
    CB' := enc(SD,VB,M',2nd(Kr')) /\
    CB' == pvPair(CM,VB') .

  rl [stutter] : {(rd-seed: null) OCs} => {(rd-seed: null) OCs} .

***(
  * eve intercepts a message m1 sent from alice to bob and
  * sends a fake message to bob
)
  rl [build-seed] : {(rd-seed: (SD, PoL)) (rd-r: (R, PoL2))
    (seeds: PoC1) (rs: PoC2) OCs}
  => {(rd-seed: PoL) (rd-r: PoL2) 
    (seeds: (SD ; PoC1)) (rs: (R ; PoC2)) OCs} .

  crl [attack1] : {(seeds: (SD ; PoC1)) (rs: (R ; PoC2))
    (nw: (m1(A,A,B, pvPair(SD-A,VB-A), sent) ; MS)) OCs}
  => {(seeds: (SD ; PoC1)) (rs: (R ; PoC2))
    (nw: (m1(A,A,B, pvPair(SD-A,VB-A), intercepted) ;
      m1(eve,A,B, pvPair(SD, VB), sent) ; MS)) OCs}
  if MA := gen-A(SD) /\
    S := gen-s(R) /\
    VB := shiftRV((tp(MA) m* S v+ h) mdv q, esq - esp) .

  rl [build-ms] : {(rd-m: (M, PoL)) (ms: PoC1) OCs}
  => {(rd-m: PoL) (ms: (M ; PoC1)) OCs} .

  crl [attack2] : {(seeds: (SD ; PoC1)) (rs: (R ; PoC2)) 
    (ms: (M ; PoC3))
    (nw: (m1(A,A,B, pvPair(SD-A,VB-A), intercepted) ;
      m1(eve,A,B, pvPair(SD,VB), replied) ;
      m2(B,B,A, pvPair(CM-B,VB'-B), sent) ; MS)) 
    (keys: KS) OCs}
  => {(seeds: (SD ; PoC1)) (rs: (R ; PoC2)) (ms: (M ; PoC3))
    (nw: (m1(A,A,B, pvPair(SD-A,VB-A), intercepted) ;
      m1(eve,A,B, pvPair(SD,VB), replied) ;
      m2(B,B,A, pvPair(CM-B,VB'-B), intercepted) ;
      m2(eve,B,A, CB, sent) ; MS)) 
    (keys: (KS ;
      key( H(1st(Kr), CB), A) ;
      key( H(1st(Kr'),CB'), B) )) OCs} 
  if MA := gen-A(SD) /\
    S := gen-s(R) /\
    VB == shiftRV((tp(MA) m* S v+ h) mdv q, esq - esp) /\
    V := tpV(VB'-B) dot S /\
    M' := shiftR((V p+ h2 p- 2 ^ (esp - esT) p* CM-B) md p, esp - 1) /\
    Kr' := G(F(pvPair(SD,VB)), M') /\
    CB' := enc(SD,VB,M',2nd(Kr')) /\
    CB' == pvPair(CM-B,VB'-B) /\ --- do not need to check

    Kr := G(F(pvPair(SD-A,VB-A)), M) /\
    CB := enc(SD-A,VB-A,M,2nd(Kr)) .

endm

search [1] in SABER : 
  init =>* {(key[alice]: key(K1,bob)) (key[bob]: key(K2,alice)) 
    (keys: (key(K1,alice) ; key(K2,bob))) OCs} .
eof

search [1] in SABER : 
  init =>* {(key[alice]: key(K1,bob)) (key[bob]: key(K1,alice)) OCs} .
eof